---
title: "WykÅ‚ad 8"
subtitle: "Obliczenia i optymalizacje"
---

{{< part "Operacje staÅ‚oprzecinkowe" >}}

{{< slide-animate "Zakresy rejestrÃ³w" >}}
	<div class="horizontal-chart">
		<div><div data-id="1b" style="width: calc(100% * pow(2, 1) / pow(2,1))">2</div></div>
		<div data-id="1l">1 bit</div>
	</div>
{{< /slide-animate >}}

{{< slide-animate "Zakresy rejestrÃ³w" >}}
	<div class="horizontal-chart">
		<div><div data-id="1b" style="width: calc(100% * pow(2, 1) / pow(2, 8))">2</div></div>
		<div data-id="1l">1 bit</div>
	</div>
	<div class="horizontal-chart">
		<div><div data-id="2b" style="width: calc(100% * pow(2, 8) / pow(2, 8))">256</div></div>
		<div data-id="2l">8 bitÃ³w</div>
	</div>
{{< /slide-animate >}}

{{< slide-animate "Zakresy rejestrÃ³w" >}}
	<div class="horizontal-chart">
		<div><div data-id="1b" style="width: calc(100% * pow(2, 1) / pow(2, 16))">2</div></div>
		<div data-id="1l">1 bit</div>
	</div>
	<div class="horizontal-chart">
		<div><div data-id="2b" style="width: calc(100% * pow(2, 8) / pow(2, 16))">256</div></div>
		<div data-id="2l">8 bitÃ³w</div>
	</div>
	<div class="horizontal-chart">
		<div><div data-id="3b" style="width: calc(100% * pow(2, 16) / pow(2, 16))">65&nbsp;536</div></div>
		<div data-id="3l">16 bitÃ³w</div>
	</div>
{{< /slide-animate >}}

{{< slide-animate "Zakresy rejestrÃ³w" >}}
	<div class="horizontal-chart">
		<div><div data-id="1b" style="width: calc(100% * pow(2, 1) / pow(2, 32))">2</div></div>
		<div data-id="1l">1 bit</div>
	</div>
	<div class="horizontal-chart">
		<div><div data-id="2b" style="width: calc(100% * pow(2, 8) / pow(2, 32))">256</div></div>
		<div data-id="2l">8 bitÃ³w</div>
	</div>
	<div class="horizontal-chart">
		<div><div data-id="3b" style="width: calc(100% * pow(2, 16) / pow(2, 32))">65&nbsp;536</div></div>
		<div data-id="3l">16 bitÃ³w</div>
	</div>
	<div class="horizontal-chart">
		<div><div data-id="4b" style="width: calc(100% * pow(2, 32) / pow(2, 32))">4&nbsp;294&nbsp;967&nbsp;296</div></div>
		<div data-id="4l">32 bitÃ³w</div>
	</div>
{{< /slide-animate >}}

{{< slide-animate "Zakresy rejestrÃ³w" >}}
	<div class="horizontal-chart">
		<div><div data-id="1b" style="width: calc(100% * pow(2, 1) / pow(2, 64))">2</div></div>
		<div data-id="1l">1 bit</div>
	</div>
	<div class="horizontal-chart">
		<div><div data-id="2b" style="width: calc(100% * pow(2, 8) / pow(2, 64))">256</div></div>
		<div data-id="2l">8 bitÃ³w</div>
	</div>
	<div class="horizontal-chart">
		<div><div data-id="3b" style="width: calc(100% * pow(2, 16) / pow(2, 64))">65&nbsp;536</div></div>
		<div data-id="3l">16 bitÃ³w</div>
	</div>
	<div class="horizontal-chart">
		<div><div data-id="4b" style="width: calc(100% * pow(2, 32) / pow(2, 64))">4&nbsp;294&nbsp;967&nbsp;296</div></div>
		<div data-id="4l">32 bitÃ³w</div>
	</div>
	<div class="horizontal-chart">
		<div><div data-id="5b" style="width: calc(100% * pow(2, 64) / pow(2, 64))">18&nbsp;446&nbsp;744&nbsp;073&nbsp;709&nbsp;551&nbsp;616</div></div>
		<div data-id="5l">64 bity</div>
	</div>
{{< /slide-animate >}}

{{< img-slide "int-c++.webp" "Typy caÅ‚kowite w C i C++" >}}
{{< note >}}W AVR <code>int</code> ma 2 bajty, <code>long</code> â€” 4, a <code>long long</code> â€” 8. <code>size_t</code> jest typu <code>unsigned int</code> i ma 2 bajty.{{< /note >}}
{{< /img-slide >}}
{{< img-slide int-rust.webp "Typy caÅ‚kowite w Rust" />}}
{{< img-slide "int-c++-std.webp" "Typy o ustalonej szerokoÅ›ci w C i C++" />}}

{{< img-slide "int.svg" "Typy o ustalonej szerokoÅ›ci w C i C++" />}}

{{< ul-slide "Kod U2 (<em>two's complement</em>)" >}}
	{{< lf >}}aby zamieniÄ‡ liczbÄ™ na przeciwnÄ…, naleÅ¼y zanegowaÄ‡ bity i dodaÄ‡ 1
	{{< lf >}}jest tylko jedno zero
	{{< lf >}}operacje na liczbach ujemnych nie wymagajÄ… specjalnego traktowania
	{{< lf >}}wynik operacji automatycznie jest poprawnÄ… wartoÅ›ciÄ… U2
{{< /ul-slide >}}

{{< part "Operacje zmiennoprzecinkowe" >}}

{{< ul-slide "Standard IEEE 754" >}}
	{{< lf >}}format zapisu liczb i wartoÅ›ci specjalnych (Â±0, Â±âˆž, <em>NaN</em>)
	{{< lf >}}arytmetyka i inne operacje (np. trygonometryczne)
	{{< lf >}}sposÃ³b zaokrÄ…glania
	{{< lf >}}obsÅ‚uga bÅ‚Ä™dÃ³w (dzielenie przez zero, przepeÅ‚nienie)
{{< /ul-slide >}}

{{< ul-slide "Podstawowe typy IEEE 754" >}}
	{{< note >}}W AVR <code>float</code> ma 4 bajty, a <code>double</code> â€” 4 lub 8, zaleÅ¼nie od opcji.{{< /note >}}
	{{< lf >}}64 bity â€” podwÃ³jna precyzja (<em>double</em>)
		<ul>
			{{< lf >}}min subnormal: \(\pm 4{,}94 \cdot 10^{âˆ’324}\)
			{{< lf >}}min normal: \(\pm 2{,}23 \cdot 10^{âˆ’308}\)
			{{< lf >}}max: \(\pm 1{,}80 \cdot 10^{308}\)
		</ul>
	{{< lf >}}32 bity â€” pojedyncza precyzja (<em>float</em>)
		<ul>
			{{< lf >}}min subnormal: \(\pm 1{,}40 \cdot 10^{âˆ’45}\)
			{{< lf >}}min normal: \(\pm 1{,}18 \cdot 10^{âˆ’38}\)
			{{< lf >}}max: \(\pm 3{,}40 \cdot 10^{38}\)
		</ul>
{{< /ul-slide >}}

{{< img-slide "float.svg" "PrzykÅ‚ady typÃ³w zmiennoprzecinkowych" />}}

{{< slide-animate "BÅ‚Ä…d zaokrÄ…glania" >}}
	{{< code lang="cpp" lines="6-10" >}}
		#include &lt;cinttypes&gt;
		#include &lt;iostream&gt;
		using namespace std;

		int main() {
			double foo = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 
					+ 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
			uint64_t foo_int = foo;
			cout << foo_int << endl;
			// ðŸ ž 0
		}
	{{< /code >}}
{{< /slide-animate >}}

{{< img-slide prove-you-are-human.webp />}}

{{< slide-animate "BÅ‚Ä…d zaokrÄ…glania" >}}
	{{< code lang="cpp" lines="7-8|10-13|15-17|19-23|25-29" >}}
		#include &lt;cinttypes&gt;
		#include &lt;iostream&gt;
		#include &lt;iomanip&gt;
		using namespace std;

		int main() {
			cout << 0.1 << endl;
			// ðŸ ž 0.1

			cout << setprecision(40);

			cout << 0.1 << endl;
			// ðŸ ž 0.1000000000000000055511151231257827021182

			cout << 0.1 + 0.1 + 0.1 + 0.1 + 0.1
					+ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 << endl;
			// ðŸ ž 0.9999999999999998889776975374843459576368
			
			cout << 0.1f << endl;
			// ðŸ ž 0.100000001490116119384765625
			cout << 0.1f + 0.1f + 0.1f + 0.1f + 0.1f
					+ 0.1f + 0.1f + 0.1f + 0.1f + 0.1f << endl;
			// ðŸ ž 1.00000011920928955078125

			cout << 0.5 << endl;
			// ðŸ ž 0.5
			cout << 0.5 + 0.5 + 0.5 + 0.5 + 0.5
					+ 0.5 + 0.5 + 0.5 + 0.5 + 0.5 << endl;
			// ðŸ ž 5
		}
	{{< /code >}}
{{< /slide-animate >}}

{{< slide-animate "Cyfry znaczÄ…ce" >}}
	{{< code lang="cpp" lines="9-11|13-15|17-19|21-23|25-27|29-31" >}}
		#include &lt;cinttypes&gt;
		#include &lt;iostream&gt;
		#include &lt;iomanip&gt;
		using namespace std;

		int main() {
			cout << setprecision(40);

			uint64_t foo = UINT64_C(12345678901234567890);
			cout << foo << endl;
			// ðŸ ž 12345678901234567890

			double foo_double = foo;
			cout << foo_double << endl;
			// ðŸ ž 12345678901234567168

			float foo_float{foo};
			cout << foo_float << endl;
			// ðŸ ž 12345679395506094080
			
			double bar_huge = 1234567890e100;
			cout << bar_huge << endl;
			// ðŸ ž 1.234567890000000078944836269502040274001e+109

			double bar_tiny = 1234567890e-100;
			cout << bar_tiny << endl;
			// ðŸ ž 1.2345678900000001211954157757914595974e-91

			double bar_inf = 1234567890e300;
			cout << bar_inf << endl;
			// ðŸ ž inf
		}
	{{< /code >}}
{{< /slide-animate >}}

{{< slide-animate "PorÃ³wnywanie wartoÅ›ci zmiennoprzecinkowych" >}}
	{{< code lang="cpp" lines="9-12|14-16|18-23|25-31" >}}
		#include &lt;cinttypes&gt;
		#include &lt;iostream&gt;
		#include &lt;iomanip&gt;
		using namespace std;

		int main() {
			cout << setprecision(40);

			double sum = 0.1 + 0.1 + 0.1 + 0.1 + 0.1
					+ 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
			cout << sum << endl;
			// ðŸ ž 0.9999999999999998889776975374843459576368

			double multiplication = 0.1 * 10;
			cout << multiplication << endl;
			// ðŸ ž 1
		 
			if (sum == multiplication) {
				cout << "OK" << endl;
			} else {
				cout << "Error" << endl;
			}
			// ðŸ ž Error
		 
			constexpr double EPSILON = 1.0 / 1000;
			if (abs(sum - multiplication) < EPSILON) {
				cout << "OK" << endl;
			} else {
				cout << "Error" << endl;
			}
			// ðŸ ž OK
		}
	{{< /code >}}
{{< /slide-animate >}}

{{< part "DomyÅ›lne typy podczas obliczeÅ„" >}}

{{< slide-animate "DomyÅ›lny typ staÅ‚oprzecinkowy" >}}
	{{< code lang="cpp" lines="6-7,9-10,12-13" >}}
		#include &lt;cinttypes&gt;
		#include &lt;iostream&gt;
		using namespace std;

		int main() {
			cout << 123'456'789 * 10 << endl;
			// ðŸ ž 1234567890

			cout << 1'123'456'789 * 10 << endl;
			// ðŸ ž -1650333998 ðŸ¤¨

			cout << 11'123'456'789 * 10 << endl;
			// ðŸ ž 111234567890
		}
	{{< /code >}}
	<div class="fragment">
	{{< code lang="plain" >}}
		foo.cpp: In function â€˜int main()â€™:
		foo.cpp:9:31: warning: integer overflow in expression
		of type â€˜intâ€™ results in â€˜-1650333998â€™ [-Woverflow]
			9 |         cout &lt;&lt; 1'123'456'789 * 10 << endl;
			  |                 ~~~~~~~~~~~~~~^~~~
	{{< /code >}}
	</div>
{{< /slide-animate >}}

{{< slide-animate "DomyÅ›lny typ staÅ‚oprzecinkowy" >}}
	{{< code lang="cpp" lines="6-7|9-10|12-13" >}}
		#include &lt;cinttypes&gt;
		#include &lt;iostream&gt;
		using namespace std;

		int main() {
			cout &lt;&lt; 1'123'456'789ll * 10 &lt;&lt; endl;
			// ðŸ ž 11234567890

			cout &lt;&lt; 1'123'456'789 * 10ll &lt;&lt; endl;
			// ðŸ ž 11234567890

			cout &lt;&lt; INT64_C(1'123'456'789) * 10 &lt;&lt; endl;
			// ðŸ ž 11234567890
		}
	{{< /code >}}
{{< /slide-animate >}}

{{< slide-animate "DomyÅ›lny typ zmiennoprzecinkowy" >}}
	{{< code lang="cpp" lines="7-8|10-12|14-15|17-23" >}}
		#include &lt;cinttypes&gt;
		#include &lt;iostream&gt;
		#include &lt;iomanip&gt;
		using namespace std;

		int main() {
			cout << 1 / 10 << endl;
			// ðŸ ž 0

			double foo = 1 / 10;
			cout << foo << endl;
			// ðŸ ž 0

			cout << 1.0 / 10 << endl;
			// ðŸ ž 0.1

			cout << setprecision(40);

			cout << 1.0 / 10 << endl;
			// ðŸ ž 0.1000000000000000055511151231257827021182

			cout << 1.0f / 10 << endl;
			// ðŸ ž 0.100000001490116119384765625
		}
	{{< /code >}}
{{< /slide-animate >}}

{{< part "SposÃ³b przeprowadzania obliczeÅ„" >}}

{{< ul-slide "FPU (<em>Floating-Point Unit</em>)" >}}
	{{< lf >}}emulacja programowa
	{{< lf >}}zewnÄ™trzny koprocesor
	{{< lf >}}wewnÄ™trzny koprocesor
	{{< lf >}}integralna czÄ™Å›Ä‡ ALU
{{< /ul-slide >}}

{{< ul-slide "FPU w procesorach ARM" >}}
	{{< lf >}}FPU (<em>Floating-Point Unit</em>)
	{{< lf >}}VFP (<em>Vector Floating Point</em>)
	{{< lf >}}Neon (aka <em>Advanced SIMD Extension</em>)
{{< /ul-slide >}}
